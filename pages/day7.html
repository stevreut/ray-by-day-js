<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ray by Day JS - Interchangeable Grid Libraries</title>
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="icon" type="image/icon" href="../assets/images/icon/ray-trace-icon.ico">
</head>
<body>
    <h1 class="subduedh1">Ray by Day JS</h1>
    <h2><span class="dayh2">Day 7</span> - Making Grid Libraries Interchangeable</h2>
    <p><strong>On Day 7, we take a significant step in the design of our graphing tools by introducing the concept of <em>abstraction</em> through the creation of a new class: <code>GenericGridGrapher</code>.</strong></p>
    <p><strong>Abstract Classes in JavaScript?</strong><br>
    While JavaScript doesn't have true abstract classes like some other languages, <code>GenericGridGrapher</code> serves as an "abstract" base class in practice. It defines a common interface and shared logic for different types of grid graphers, but isn't meant to be used directly. Instead, specific implementations inherit from it and provide their own rendering logic.</p>
    <p><strong>Polymorphism in Action</strong><br>
    To demonstrate the power and flexibility of this abstraction, you can use the toggle below to switch between two different implementations:</p>
    <ul class="narrative-list">
      <li><strong>SVGGridGrapher:</strong> Renders the grid using SVG, as in previous days.</li>
      <li><strong>TableGridGraph:</strong> Renders the same function using an HTML <code>&lt;table&gt;</code>. This is intentionally a "silly and pointless" implementation, included only to show how easy it is to swap out rendering methods when using an abstract base class.</li>
    </ul>
    <p><strong>Why does this matter?</strong><br>
    This exercise highlights the benefits of object-oriented programming (OOP) principles like abstraction and polymorphism. By coding to an abstract interface, you can easily extend or modify your program's behavior without changing its core logic.</p>
    <p>Try toggling between the two implementations and observe how the same function is rendered in completely different ways. Consider how this approach could be used to add new rendering methods in the future.</p>
    <div class="imgdiv">
        <h3 id="imgh3">SVG dynamically created ... 
        </h3>
        <p id="svghere" style="margin-bottom:2cm;">SVG should be produced here on script load.</p>
        <p><button id="togglebtn">toggle Gridder</button></p>
        <p>
            <label for="gridtxt">Gridder extending class used: </label>
            <input type="text" id="gridtxt" readonly></p>
    </div>
    <h3 class="resource-index-header">Resources used in this page</h3>
    <div id="resource-index"></div>
    <script type="module">
        import CodeFormatter from "../assets/js/utils/code-ext/code-formatter.js";
        const cf = new CodeFormatter();
        cf.insertResourceIndex("resource-index", [
            "./day7.html",
            "../assets/js/day7/script.js",
            "../assets/js/day7/bivargrapher.js",
            "../assets/js/day7/gen-grid-grapher.js",
            "../assets/js/day7/svg-grid-grapher.js",
            "../assets/js/day7/tablegridgraph.js",
            "../assets/js/day4/svgutils.js"
        ]);
    </script>
    <div class="hopdiv">
        <a href="./day6.html">Prev</a>
        <a href="../index.html">Home</a>
        <a href="./day8.html">Next</a>
    </div>
    <script src="../assets/js/day7/script.js" type="module"></script>
</body>
</html>